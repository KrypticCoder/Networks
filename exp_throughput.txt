#enable packet arrival at simultaneous time
        for x in range(self.num_hosts):
            self.env.process(self.hosts[x].packets_arrival(self.env))

        while True:
            #wait for slot time
            yield self.env.timeout(self.slot_length)
            #print("=====================")
            #print("Time ", self.env.now)
            #print("Slot number", self.slot_number)
            request = 0 #how many request at current slot?
            host_index = -1 #index of the first request
            for x in range(self.num_hosts):
                if(self.hosts[x].queue_len == 0):
                    continue#don't even care if hosts have no queue, packets
                
                #hosts queue have packets,
                # update their slot if they are behind current slot
                if((self.hosts[x].transmit_slot <= self.slot_number)):
                    request += 1
                    self.hosts[x].transmit_slot = self.slot_number
                    host_index = x

                #print("Host ", x, " can possibly transmit at slot ", self.hosts[x].transmit_slot, "Queue is ", self.hosts[x].queue_len)
                #count only hosts that have stuff to transmit
            #print("total host request at current slot: ", request)

            #allow the host to process
            if request == 1:
                self.success_slots += 1
                #print(">>Can TRANSMIT<< since request = 1")
                self.hosts[host_index].process_packet(self.env, self.server)
            
            #more than 1 request? then go through and delay each hosts that requested
            elif request > 1:
                self.collision_slots += 1
                for x in range(self.num_hosts):
                    if(self.hosts[x].transmit_slot == self.slot_number) and (self.hosts[x].queue_len > 0):
                        self.hosts[x].delay_transmission_lin()

            elif request == 0:
                self.empty_slots += 1          

            self.slot_number += 1